## Сортировки   
#### O-notation  
Временная: примерная итерация алгоритма  
О(1) – любая константная вещь, которая у нас присутствует  
O(n) - Зависит от количество входных данных или, например, проход for i in range.

#### Пузырьковая сортировка 
пробегаться по массиву и смотреть на два соседних числа. Требуется О(n) времени как минимум.  
5 6 2 4 1  
5 2 4 1 6  
2 4 1 5 6  
2 1 4 5 6  
1 2 4 5 6  
1 2 4 5 6  
O(n(пробег по массиву) * n(количество итераций) ) = O(n^2)  
Это in-place сортировка, то есть сортировка проходит внутри массива.  

#### Сортировка вставками
5 3 6 1 4 (1, 4)  
__1__ 3 6 5 4 (3, 2)  
__1 3__ 6 5 4 (4, 5)  
__1 3 4__ 5 6 (5, 4)  
__1 3 4 5__ 6 (6, 5)  
__1 3 4 5 6__  

O(n^2), in-place сортировка  

Сортировка подсчетом - алгоритм сортировки, в котором используется диапазон чисел сортируемого массива для подсчёта совпадающих элементов.
Время: O(n), Память: O(A)

#### MergeSort  
10 3 5 8 6 2 1 4 7  
10, 3, 5, 8| 6, 2, 1, 4, 7    Делим массив пополам  
9, 10 | 3, 5, 8  
9 | 10 Массив из одного элемента является уже отсортированным  
9, 10   

Merge (a, b) :  Время: O(n)  
a: 3, 5, 8, 9, 10  
b: 1, 2, 4, 6, 7  

Сравниваем два указателя 3 и 1. 3 > 1, значит сдвигаем указатель с 1 на 2. 3 > 2. Сдвигаем указатель на 3. Сравниваем 3 и 4, 3 < 4 и т.д.
5 > 4    
5 < 6  
8 > 6  
7 < 8  указатель b дошел до конца. Это значит всю оставшуюся часть указателя можно просто переписать.

1 2 3 4 5 6 7 8 9 10

    def merge sort(a):
	    x = merge sort (a [://2])
	    y = merge sort(a [//2:])
	return merge ()

#### Quick sort – это in place сортировка 

Это алгоритм сортировки, сложность которого в среднем составляет O(n log(n)). Суть его предельно проста: выбирается так называемый опорный элемент, и массив делится на 3 подмассива: меньших опорного, равных опорному и больших опорного. Потом этот алгоритм применяется рекурсивно к подмассивам (Habr).  
M: O (1)   
Среднее время работы O(nlogn)  
Но может O (n^2)  

Есть массив  
1 8 6 2 3 5 9 4 7 10     
Берем среднее. Относительно этого среднего делаем правое (больше 3) и левое (меньше или равно 3) множество. Берем левый указатель, берем правый указатель. Начинаем сдвигать указатели. Левый указатель сдвигаем пока не встретится элемент, который строго больше 3, а правый указатель пока меньше или равен 3.

1 8 6 2 __3__ 5 9 4 7 10     
Левый указатель останавливается на 8. Правый на 3. Меняем местами.  
1 3 6 2 8 5 9 4 7 10  
Повторяем операцию. Левый указатель останавливается на 6. Правый на 2. Меняем местами.  
1 3 2 6 8 5 9 4 7 10  
Теперь мы может разделить наш массив на две части, где слева все меньше или равно 3, справа все больше 3.   
1 3 2 | 6 8 5 9 4 7 10  
Проделываем тоже самое для 9. Получается  
1 3 2 | 6 8 5 9 4 7 | 10  
Проделываем это до того момента, пока у нас не будут единичные партиции  .

Проблемы!  
Например:  
1 3 2   
Проблема: пустая правая часть и полная левая. Решение: делить не на две партиции, а на три <   ==   >
